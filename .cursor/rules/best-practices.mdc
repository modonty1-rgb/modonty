---
description: Comprehensive best practices for Next.js/React monorepo - consolidated documentation
alwaysApply: true
---

# Best Practices - Consolidated Rules

## ğŸš¨ FOCUSED TASK RULES - MANDATORY COMPLIANCE

### PRIMARY RULE: FOCUS ON TASK ONLY

- Make ONLY the requested changes
- Preserve existing functionality exactly
- Never modify unrelated code sections
- Never change styling of other components
- Never touch code outside the specific task

### FORBIDDEN BEHAVIORS

- âŒ Modify unrelated code sections
- âŒ Change styling of other components
- âŒ Touch code outside specific task
- âŒ Make "improvements" not requested
- âŒ Refactor existing working code
- âŒ Assume user wants cleanup
- âŒ Add features not requested

### REQUIRED PROTOCOL

**Before Changes:**

- Identify exactly what needs to change
- Locate only specific code section
- Plan minimal change required
- Verify no other code affected

**During Changes:**

- Make only requested modification
- Preserve all existing styling
- Preserve all existing functionality
- Don't improve or cleanup other code

**After Changes:**

- Verify specific task works
- Confirm other components unchanged
- Test existing functionality preserved
- Report only what was changed

### VERIFICATION CHECKLIST

- [ ] Only requested feature modified
- [ ] No unrelated code touched
- [ ] Existing styling preserved
- [ ] Other components work as before
- [ ] No unintended side effects

### EMERGENCY STOP

If about to:

- Modify unrelated code
- Change existing styling
- Touch working functionality
- Make unrequested improvements

Then:

- STOP immediately
- Ask for clarification
- Confirm exact scope
- Make only requested change

### EXAMPLES

âœ… CORRECT: "Make cancel reason full width" â†’ Only modify cancel reason container
âŒ WRONG: "Make cancel reason full width" â†’ Modify cancel reason AND change driver styling

**This rule is MANDATORY. No exceptions. No side effects. Only requested task.**

---

## ğŸ“ FOLDER STRUCTURE RULE

### Route-Based Organization Principle

**Key Rule**: Each route can have its own `components/`, `actions/`, and `helpers/` folders for route-specific code. Shared code goes in root-level folders.

### Standard Folder Organization

- **Route-specific code** â†’ Inside route folder (`app/[route]/components/`, `app/[route]/actions/`, `app/[route]/helpers/`)
- **Shared code** â†’ Root level (`app/components/`, `app/actions/`, `app/helpers/`)
- **Core libraries** â†’ Always in `lib/` (Prisma, auth, utils, validations)

### Visual Folder Structure

```
ğŸ“¦ app/                          # Your Next.js app directory
â”‚
â”œâ”€â”€ ğŸ“ [route]/                  # ğŸ¯ ROUTE-SPECIFIC CODE
â”‚   â”œâ”€â”€ page.tsx                 # Route page
â”‚   â”œâ”€â”€ loading.tsx              # Loading UI
â”‚   â”œâ”€â”€ error.tsx                # Error UI
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ components/           # Route-only components
â”‚   â”‚   â”œâ”€â”€ route-card.tsx
â”‚   â”‚   â””â”€â”€ route-form.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ actions/              # Route-only actions
â”‚   â”‚   â””â”€â”€ route-actions.ts
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ helpers/              # Route-only helpers
â”‚       â”œâ”€â”€ hooks/
â”‚       â”‚   â””â”€â”€ use-route-data.ts
â”‚       â””â”€â”€ utils/
â”‚           â””â”€â”€ route-utils.ts
â”‚
â”œâ”€â”€ ğŸ“ dashboard/                # Example: Dashboard route
â”‚   â”œâ”€â”€ page.tsx
â”‚   â”œâ”€â”€ loading.tsx
â”‚   â”œâ”€â”€ components/              # Dashboard-only components
â”‚   â”‚   â”œâ”€â”€ stats-card.tsx
â”‚   â”‚   â””â”€â”€ chart.tsx
â”‚   â”œâ”€â”€ actions/                 # Dashboard-only actions
â”‚   â”‚   â””â”€â”€ dashboard-actions.ts
â”‚   â””â”€â”€ helpers/                 # Dashboard-only helpers
â”‚       â””â”€â”€ hooks/use-dashboard.ts
â”‚
â”œâ”€â”€ ğŸ“ auth/                     # Example: Auth route
â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ components/          # Login-only components
â”‚   â”‚   â”‚   â””â”€â”€ login-form.tsx
â”‚   â”‚   â””â”€â”€ actions/             # Login-only actions
â”‚   â”‚       â””â”€â”€ login-actions.ts
â”‚   â””â”€â”€ signup/
â”‚       â”œâ”€â”€ page.tsx
â”‚       â””â”€â”€ components/
â”‚           â””â”€â”€ signup-form.tsx
â”‚
â”œâ”€â”€ ğŸ“ components/               # ğŸŒ SHARED COMPONENTS (used by multiple routes)
â”‚   â”œâ”€â”€ ğŸ“ ui/                   # shadcn/ui base components
â”‚   â”‚   â”œâ”€â”€ button.tsx
â”‚   â”‚   â”œâ”€â”€ input.tsx
â”‚   â”‚   â”œâ”€â”€ dialog.tsx
â”‚   â”‚   â””â”€â”€ card.tsx
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ shared/               # Shared UI components
â”‚       â”œâ”€â”€ header.tsx
â”‚       â”œâ”€â”€ footer.tsx
â”‚       â””â”€â”€ navigation.tsx
â”‚
â”œâ”€â”€ ğŸ“ actions/                   # ğŸŒ SHARED ACTIONS (used by multiple routes)
â”‚   â”œâ”€â”€ auth-actions.ts          # Shared auth logic
â”‚   â”œâ”€â”€ user-actions.ts          # Shared user operations
â”‚   â””â”€â”€ common-actions.ts        # Common operations
â”‚
â”œâ”€â”€ ğŸ“ helpers/                   # ğŸŒ SHARED HELPERS (used by multiple routes)
â”‚   â”œâ”€â”€ ğŸ“ hooks/                # Shared custom hooks
â”‚   â”‚   â”œâ”€â”€ use-auth.ts
â”‚   â”‚   â”œâ”€â”€ use-local-storage.ts
â”‚   â”‚   â””â”€â”€ use-debounce.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ utils/                # Shared utility functions
â”‚   â”‚   â”œâ”€â”€ format-date.ts
â”‚   â”‚   â”œâ”€â”€ validate-email.ts
â”‚   â”‚   â””â”€â”€ format-currency.ts
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ constants/            # Shared constants
â”‚       â”œâ”€â”€ routes.ts
â”‚       â””â”€â”€ api-endpoints.ts
â”‚
â””â”€â”€ ğŸ“ lib/                       # ğŸ“š CORE LIBRARIES (always shared)
    â”œâ”€â”€ prisma.ts                # Prisma client instance
    â”œâ”€â”€ auth.ts                  # Auth configuration
    â”œâ”€â”€ utils.ts                 # Core utilities
    â””â”€â”€ validations.ts           # Zod schemas
```

### What Goes Where?

| Location                  | Purpose                    | When to Use                            |
| ------------------------- | -------------------------- | -------------------------------------- |
| `app/[route]/components/` | **Route-specific UI**      | Components used ONLY in this route     |
| `app/[route]/actions/`    | **Route-specific actions** | Server actions used ONLY in this route |
| `app/[route]/helpers/`    | **Route-specific helpers** | Hooks/utils used ONLY in this route    |
| `app/components/`         | **Shared UI**              | Components used by 2+ routes           |
| `app/actions/`            | **Shared actions**         | Server actions used by 2+ routes       |
| `app/helpers/`            | **Shared helpers**         | Hooks/utils used by 2+ routes          |
| `app/lib/`                | **Core libraries**         | Always shared (Prisma, auth, etc.)     |

### Decision Tree

```
Is the code used in only ONE route?
â”œâ”€â”€ YES â†’ Put it in app/[route]/components|actions|helpers/
â””â”€â”€ NO â†’ Put it in app/components|actions|helpers/
```

### Folder Creation Rules

- âœ… If route folder doesn't exist â†’ Create it with `page.tsx`
- âœ… If route-specific folder needed â†’ Create `components/`, `actions/`, or `helpers/` inside route
- âœ… If shared folder doesn't exist â†’ Create it at root + add `README.md`
- âœ… Always check: Is this used by multiple routes? â†’ Move to shared folder

### âŒ Avoid These Folder Names

- `misc/`, `temp/`, `old/` - Use proper feature-based organization
- `hooks/` - Use `helpers/hooks/` instead
- `utils/` - Use `helpers/utils/` instead

### âœ… Real-World Examples

**Route-Specific (Dashboard):**

```
app/dashboard/
â”œâ”€â”€ page.tsx
â”œâ”€â”€ loading.tsx
â”œâ”€â”€ components/
â”‚   â””â”€â”€ dashboard-stats.tsx      âœ… Only used in dashboard
â”œâ”€â”€ actions/
â”‚   â””â”€â”€ fetch-dashboard-data.ts  âœ… Only used in dashboard
â””â”€â”€ helpers/
    â””â”€â”€ hooks/use-dashboard.ts   âœ… Only used in dashboard
```

**Shared (Used by Multiple Routes):**

```
app/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/button.tsx            âœ… Used everywhere
â”‚   â””â”€â”€ shared/header.tsx        âœ… Used in multiple routes
â”‚
â”œâ”€â”€ actions/
â”‚   â””â”€â”€ auth-actions.ts          âœ… Used in login, signup, profile
â”‚
â””â”€â”€ helpers/
    â””â”€â”€ hooks/use-auth.ts        âœ… Used in multiple routes
```

This keeps the project organized, scalable, and easy to understand!

---

## ğŸ“¦ COMPONENT SIZE RULE

### File Organization

- Keep file count low
- Each file should have a single specific job
- Avoid having too many files

### Component Guidelines

- **Maximum Lines**: 200 lines per component
- **Maximum Functions**: 5 functions per component
- **Single Responsibility**: Each component should do one thing well

### When to Split

- Component exceeds 200 lines â†’ Split into smaller components
- Component has more than 5 functions â†’ Extract logic to helpers/hooks
- Component handles multiple concerns â†’ Separate into focused components

---

## ğŸ¨ UI COLORS RULE

### Color Usage

- âŒ **NEVER** use hardcoded color values in the codebase
- âœ… **ALWAYS** use theme tokens or CSS variables for all colors
- âœ… **ALWAYS** use Tailwind utility classes (bg-, text-, border-, etc.)

### Examples

âŒ **WRONG:**

```tsx
<div style={{ color: '#0073b1' }}>Text</div>
<div className="text-[#0073b1]">Text</div>
```

âœ… **CORRECT:**

```tsx
<div className="text-primary">Text</div>
<div className="bg-background text-foreground">Text</div>
```

### Theme Tokens

Use semantic color tokens from your design system:

- `bg-background`, `text-foreground`
- `bg-primary`, `text-primary`
- `bg-secondary`, `text-secondary`
- `bg-muted`, `text-muted`
- etc.

---

## ğŸ—ï¸ STATE MANAGEMENT RULE

### Preferred Approach

- **Prefer Zustand** for state management over React Context to avoid extra renders
- Use React Context only for theme, auth, or other app-wide concerns
- Use local state (`useState`, `useReducer`) for component-specific state

### When to Use What

- **Zustand**: Global state that needs frequent updates
- **React Context**: Theme, language, auth (rarely changing)
- **Local State**: Component-specific UI state
- **Server State**: Use React Query/SWR for server data

---

## ğŸ’ SOLID PRINCIPLES & CODE SIMPLICITY

### SOLID Principles

#### S - Single Responsibility Principle (SRP)

- Each component should have a single responsibility
- Each function should do one thing well
- Avoid complex logic in components - extract to helpers or hooks
- One class/component = one reason to change

#### O - Open/Closed Principle (OCP)

- Components should be open for extension, closed for modification
- Use composition and props to extend functionality
- Avoid modifying existing components - create new ones or use wrappers
- Prefer extending through props, hooks, or higher-order components

#### L - Liskov Substitution Principle (LSP)

- Derived components should be substitutable for their base components
- Components should honor their contracts (props, behavior)
- Don't break parent component expectations when extending
- Maintain consistent interfaces across component hierarchies

#### I - Interface Segregation Principle (ISP)

- Don't force components to depend on props they don't use
- Split large prop interfaces into smaller, focused ones
- Create specific interfaces for specific use cases
- Prefer many small, focused props over one large prop object

#### D - Dependency Inversion Principle (DIP)

- Depend on abstractions, not concretions
- Use dependency injection for services and utilities
- Components should depend on interfaces/types, not implementations
- Inject dependencies through props, context, or hooks

### KISS Principle (Keep It Simple, Stupid)

- **Simplicity First**: Prefer simple solutions over complex ones
- **Avoid Over-Engineering**: Don't add complexity until it's needed
- **Clear and Readable**: Code should be easy to understand at first glance
- **Minimal Abstraction**: Only abstract when it provides clear value
- **Straightforward Logic**: Use direct approaches over clever tricks
- **Be careful and accurate, avoid errors**
- **Use short comments (only when necessary)**
- **Always check the codebase before responding or planning**

### DRY Principle (Don't Repeat Yourself)

- **Extract Common Logic**: Move repeated code to shared functions/hooks
- **Reusable Components**: Create shared components for repeated UI patterns
- **Single Source of Truth**: Define constants, types, and configs once
- **Avoid Duplication**: If you write the same code twice, extract it
- **Shared Utilities**: Put common functions in `helpers/utils/`
- **Shared Hooks**: Put reusable logic in `helpers/hooks/`
- **Shared Actions**: Put common server actions in `app/actions/`

### Best Practices

- Keep functions small and focused (max 200 lines, max 5 functions)
- Extract complex logic to helper functions
- Use meaningful variable and function names
- Prefer composition over inheritance
- Write self-documenting code
- Remove code duplication immediately
- Choose the simplest solution that works

---

## ğŸ§¹ CLEANUP CHECKLIST

### Before Merging/Committing

Remove all of the following:

- [ ] **TODO comments** - `// TODO` or `// FIXME`
- [ ] **Console logs** - `console.log()`, `console.error()`, etc.
- [ ] **Debugger statements** - `debugger`
- [ ] **Old code** - Unused imports, dead code, commented-out code
- [ ] **Var declarations** - Use `let` or `const` instead of `var`

### Code Quality

- [ ] No `any` types - Use proper TypeScript types
- [ ] No `require()` - Use ES6 `import` syntax
- [ ] All logic in functions/variables - Not in global scope
- [ ] Proper error handling - Try/catch for error-prone code

---

## âœ… GENERAL BEST PRACTICES

### Code Quality

- Be careful and accurate, avoid errors
- Use short comments (only when necessary)
- Avoid complex code
- Always check the codebase before responding or planning

### TypeScript

- Avoid `any` type - Use proper types
- Define Props interfaces/types for components
- Use strict TypeScript configuration

### Performance

- Use `key` prop when rendering lists
- Avoid excessive inline styles
- Use `useEffect` for localStorage access (not in render)
- Consider `React.memo` for pure components

### Security

- Never use `eval()`
- Avoid `dangerouslySetInnerHTML` (use sanitization if needed)
- Avoid direct `innerHTML` manipulation
- Use secure methods for cookies

### Forms

- Use React Hook Form for all forms
- Use Zod for validation schemas
- Use `zodResolver` with React Hook Form
- Show validation errors using `formState.errors`
- Use consistent form field components

### SEO

- All pages must have `<title>` or `generateMetadata`
- All pages should have meta description
- All pages should have main heading (`<h1>`)

### Error Handling

- Use try/catch for error-prone code
- Handle errors in catch blocks
- Use Error objects when throwing (not strings)

---

## ğŸ“ TODO LIST RULE

- Always update the TODO list after each check
- Remove TODO comments before merging
- Track progress and mark tasks as complete

---

**Remember**: These rules ensure code quality, maintainability, and production safety. Follow them consistently across the entire monorepo.
